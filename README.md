# Fullstack Developer Knowledge Map

Этот репозиторий — структурированная шпаргалка для подготовки к техническим заданиям и собеседованиям на позиции Backend/Frontend/Fullstack. Здесь вы найдёте теорию, практические советы и примеры кода по ключевым темам.

## Оглавление

1. [JavaScript / TypeScript](./README_JS.md)
2. [Frontend: React / Next.js](./README_Frontend.md)
3. [Backend: Node.js и современные практики](./README_Backend.md)
4. [Общие навыки и DevOps](./README_DevOps.md)

Каждый раздел содержит подробные теоретические материалы, примеры кода и рекомендации для подготовки к техническим заданиям.

## 1. JavaScript / TypeScript

- **Глубокое понимание прототипов, замыканий и асинхронности**
  - **Прототипы:**  
    Прототипное наследование — основа объектной модели JavaScript. Каждый объект имеет внутреннее свойство [[Prototype]], которое указывает на другой объект (прототип). Если свойство не найдено у текущего объекта, поиск продолжается по цепочке прототипов до Object.prototype. Понимание работы new, Object.create, отличий классов ES6 от прототипов важно для грамотного проектирования архитектуры. Прототипы позволяют реализовывать наследование, делиться методами между объектами и экономить память.
  - **Замыкания:**  
    Замыкание — это функция, которая запоминает область видимости, в которой была создана, даже после выхода из этой области. Используются для создания приватных переменных, функций с памятью, инкапсуляции состояния. Замыкания лежат в основе модулей, итераторов, функций обратного вызова и асинхронного программирования. Важно понимать, как замыкания влияют на сборку мусора и утечки памяти.
  - **Асинхронность:**  
    Асинхронное программирование в JS реализуется через колбэки, промисы, async/await. Event loop управляет очередями задач (microtask, macrotask), что определяет порядок выполнения кода. Важно уметь обрабатывать ошибки в асинхронном коде, избегать callback hell, использовать промисы для цепочек асинхронных операций, понимать разницу между micro/macro task, особенности работы setTimeout, setImmediate, process.nextTick.

- **Современные возможности языка (ES6+)**
  - **Деструктуризация, spread/rest:**  
    Позволяют удобно извлекать значения из объектов и массивов, собирать остаточные параметры, упрощают работу с данными и повышают читаемость кода. Деструктуризация применяется для параметров функций, возврата значений, копирования и объединения структур данных.
  - **Модули (import/export):**  
    Модульная система позволяет разделять код на независимые части, облегчает тестирование, повторное использование и поддержку. ES-модули (import/export) поддерживают статический анализ, tree-shaking, работают на уровне сборщиков и браузеров. Отличие от CommonJS (require/module.exports) — статичность и возможность оптимизации.
  - **Работа с npm/yarn/pnpm:**  
    Современные менеджеры пакетов обеспечивают управление зависимостями, автоматизацию сборки, публикацию собственных пакетов. Важно знать команды для установки, обновления, удаления пакетов, работу с lock-файлами, настройку скриптов.
  - **Линтинг и форматирование:**  
    Использование инструментов (ESLint, Prettier) для поддержания чистоты и единообразия кода. Линтеры помогают выявлять ошибки, несоответствия стилю, потенциальные баги до запуска приложения. Форматтеры автоматизируют оформление кода.

- **TypeScript как must-have**
  - **Типизация:**  
    TypeScript расширяет JavaScript статической типизацией. Позволяет объявлять интерфейсы, типы, использовать generics, union/intersection types. Типизация помогает предотвращать ошибки на этапе компиляции, улучшает автодополнение и рефакторинг.
  - **Type Guards:**  
    Пользовательские функции для сужения типов, обеспечивают безопасность при работе с неизвестными или any-типами. Позволяют строить надёжные проверки и избегать ошибок рантайма.
  - **TS-конфиг и strict-режимы:**  
    Конфигурация TypeScript (tsconfig.json) определяет правила компиляции, пути, строгие режимы (strict, noImplicitAny, strictNullChecks и др.), что минимизирует ошибки и повышает надёжность кода. Важно уметь настраивать проект под нужды команды.

- **Тестирование**
  - **Юнит-тесты (Jest/Mocha):**  
    Юнит-тесты проверяют отдельные функции и модули на корректность работы. Позволяют выявлять ошибки на ранних этапах, ускоряют рефакторинг, служат документацией для кода.
  - **TDD/BDD:**  
    Разработка через тестирование (Test-Driven Development, Behavior-Driven Development) помогает писать более надёжный, гибкий и поддерживаемый код. Сначала пишутся тесты, затем реализация.
  - **Тестирование асинхронного кода:**  
    Для проверки асинхронных функций используются async/await в тестах, мок-объекты, специальные методы тестовых фреймворков. Важно уметь тестировать промисы, обработку ошибок, тайминги и побочные эффекты.

---

## 2. Frontend: React / Next.js

- **React (hooks, архитектура, best practices)**
  - **Хуки:**  
    Хуки — функции, позволяющие использовать состояние и другие возможности React без написания классов. useState управляет локальным состоянием, useEffect — побочными эффектами, useCallback и useMemo — оптимизацией производительности, useRef — доступом к DOM и сохранением мутабельных значений, useContext — глобальными данными. Грамотное использование хуков позволяет строить чистые, переиспользуемые компоненты и избегать дублирования логики.
  - **Архитектурные паттерны:**  
    В React используются паттерны HOC (Higher-Order Component), render props, контейнерные и презентационные компоненты для разделения ответственности, повышения переиспользуемости и тестируемости кода. Важно понимать, когда применять тот или иной паттерн, чтобы не усложнять архитектуру.
  - **Оптимизация:**  
    Для повышения производительности применяются React.memo (мемоизация компонентов), Suspense и lazy loading (отложенная загрузка), code splitting (разделение кода на чанки). Это снижает время загрузки и повышает отзывчивость приложения.

- **Жизненный цикл компонента**
  - Управление side-effects (побочными эффектами), очистка ресурсов, оптимизация рендеров. В функциональных компонентах жизненный цикл реализуется через useEffect и его зависимости. Важно правильно очищать слушатели событий, таймеры и другие ресурсы, чтобы избежать утечек памяти и багов.
  - Error boundaries используются для отлова ошибок в UI и предотвращения падения всего приложения. Позволяют изолировать сбои и показывать fallback-интерфейсы.

- **Next.js (SSR / CSR / ISR / SSG)**
  - SSR (Server-Side Rendering): серверный рендеринг страниц для SEO и быстрой первой отрисовки. Используется getServerSideProps.
  - CSR (Client-Side Rendering): рендеринг на клиенте, подходит для динамических интерфейсов и интерактивных страниц.
  - ISR (Incremental Static Regeneration): инкрементальная генерация страниц с возможностью обновления по таймеру (revalidate), сочетает плюсы SSR и SSG.
  - SSG (Static Site Generation): генерация статических страниц на этапе сборки, обеспечивает максимальную производительность и безопасность. Используется getStaticProps.
  - Важно выбирать подходящий способ рендеринга в зависимости от требований к актуальности данных, SEO и производительности.

- **Работа с формами**
  - Использование Formik, React Hook Form для управления состоянием формы, валидации, интеграции с библиотеками проверки схем (yup, zod). Эти инструменты упрощают работу с большими и сложными формами, обеспечивают масштабируемость и удобство тестирования.
  - Контролируемые компоненты управляются через state, неконтролируемые — через ref. Контролируемый подход обеспечивает предсказуемость и интеграцию с валидацией.
  - Валидация форм может выполняться как на клиенте (через yup/zod), так и на сервере (через Joi, class-validator), что повышает надёжность и безопасность.

- **Управление состоянием**
  - Context API, Redux Toolkit, Zustand используются для управления глобальным состоянием в приложениях разного масштаба. Context подходит для простых данных (тема, язык), Redux — для сложных и масштабируемых приложений, Zustand — для лёгких и производительных решений.
  - Middleware (redux-thunk, redux-saga) позволяют реализовывать асинхронные действия, логирование, обработку побочных эффектов.
  - Важно выбирать инструмент в зависимости от сложности приложения и требований к масштабируемости.

- **Адаптивная и современная вёрстка**
  - CSS/SCSS обеспечивают базовые стили, вложенность, переменные, миксины. SCSS расширяет возможности CSS за счёт препроцессинга.
  - CSS-in-JS (styled-components, Emotion) позволяет писать стили прямо в JS/TS, использовать динамические значения, темы, изоляцию стилей.
  - Tailwind — utility-first CSS-фреймворк, ускоряющий разработку за счёт готовых классов.
  - Mobile-first подход: сначала разрабатываются стили для мобильных устройств, затем с помощью media queries добавляются стили для десктопа. Это обеспечивает лучшую адаптивность и производительность.

- **Взаимодействие с backend**
  - REST и GraphQL — основные подходы к обмену данными между frontend и backend. Для работы с API используются axios, fetch, Apollo Client.
  - Авторизация реализуется через JWT, OAuth, хранение токенов в httpOnly cookie для защиты от XSS.
  - Кэширование и повторные запросы (retry) реализуются с помощью SWR, React Query, что повышает производительность и устойчивость приложения.
  - Безопасное хранение токенов — важный аспект защиты пользовательских данных.

- **Тестирование**
  - Unit-тесты (Jest, Testing Library) проверяют отдельные компоненты и функции.
  - E2E-тесты (Cypress, Playwright) обеспечивают проверку работы приложения в целом, включая взаимодействие с backend.
  - Mock-сервисы (msw — Mock Service Worker) позволяют имитировать работу backend для тестирования frontend в изоляции.

---

## 3. Backend (Node.js + современные практики)

- **Node.js (экосистема, паттерны, инструменты)**
  - Node.js — среда выполнения JavaScript вне браузера, основана на движке V8. Ключевые особенности: асинхронность, событийно-ориентированная архитектура, неблокирующий ввод-вывод. Event loop управляет обработкой событий и задач. Streams и buffer используются для эффективной работы с потоками данных. Express, Fastify, Koa — популярные фреймворки для построения REST API и middleware. JWT, OAuth, session/cookie, refresh-токены — основные подходы к аутентификации и авторизации. Централизованный error handling и логирование (winston, pino) обеспечивают поддержку и мониторинг приложений.

- **Архитектура и масштабирование**
  - Чистая архитектура, SOLID, CQRS, DDD — современные подходы к проектированию масштабируемых и поддерживаемых систем. DTO (Data Transfer Object), сервисный слой, репозитории — паттерны для разделения ответственности и упрощения тестирования. Микросервисы позволяют строить независимые сервисы, взаимодействующие через очереди (RabbitMQ, Kafka), WebSocket, фоновые задачи. Важно уметь организовывать обработку фоновых задач с помощью очередей и worker-процессов для повышения производительности и отказоустойчивости.

- **Работа с БД**
  - Реляционные базы данных (PostgreSQL, MySQL) и NoSQL (MongoDB, Redis) используются в зависимости от требований к структуре и объёму данных. ORM/ODM (Prisma, TypeORM, Mongoose) упрощают работу с БД, обеспечивают абстракцию и безопасность. Транзакции, индексация, оптимизация запросов, миграции — ключевые аспекты эффективной работы с данными. Параметризованные запросы, ORM и валидация данных защищают от SQL-инъекций и других атак.

- **Тестирование и CI/CD**
  - Модульные, интеграционные, контрактные тесты обеспечивают надёжность и предсказуемость backend-систем. Использование mock-данных, Testcontainers для изоляции тестов. CI/CD (GitHub Actions, Gitlab CI) автоматизируют тестирование и деплой, обеспечивают быстрый feedback и стабильность релизов. Деплой через Docker и Kubernetes позволяет масштабировать и управлять инфраструктурой.

- **Безопасность**
  - Валидация входных данных, защита от XSS, CSRF, SQL/NoSQL injection — обязательные меры для обеспечения безопасности приложений. Использование HTTPS, CORS, security headers, rate limiting снижает риски атак. Важно регулярно обновлять зависимости, проводить аудит безопасности и использовать best practices.

---

## 4. Общие навыки и DevOps

- **Git, workflow (GitFlow, trunk-based)**
  - Git — распределённая система контроля версий, позволяющая отслеживать изменения, работать с ветками, сливать и откатывать изменения. Важно знать основные команды (commit, branch, merge, rebase, cherry-pick, revert), уметь разрешать конфликты. GitFlow — стратегия ветвления с разделением на master, develop, feature, release, hotfix ветки. Trunk-based development — подход с одной основной веткой, быстрыми короткими фичами и частыми интеграциями. Выбор workflow зависит от размера команды и требований к релизам.

- **Docker, docker-compose, основы Kubernetes**
  - Docker — инструмент для контейнеризации приложений, обеспечивает изоляцию, переносимость и воспроизводимость среды. Dockerfile описывает, как собрать образ. docker-compose позволяет запускать несколько контейнеров вместе, определяя их зависимости. Kubernetes — система оркестрации контейнеров, автоматизирует развертывание, масштабирование и управление приложениями в кластере. Важно понимать базовые объекты (Pod, Service, Deployment), принципы масштабирования и обновления.

- **CI/CD: пайплайны, автоматизация тестов и деплоя**
  - CI/CD (Continuous Integration/Continuous Delivery/Deployment) — практика автоматизации сборки, тестирования и доставки кода. Пайплайны (GitHub Actions, Gitlab CI, Jenkins) позволяют запускать тесты, линтеры, сборку и деплой при каждом изменении в репозитории. Это ускоряет выпуск новых версий, снижает количество ошибок и повышает надёжность релизов.

- **Мониторинг и логирование (Prometheus, Grafana, Sentry)**
  - Мониторинг — отслеживание состояния и производительности приложений, инфраструктуры. Prometheus собирает метрики, Grafana визуализирует их в виде дашбордов. Sentry — инструмент для отслеживания ошибок и исключений в реальном времени. Важно настраивать алерты, собирать логи, анализировать метрики для быстрого реагирования на инциденты.

- **Английский: чтение документации, code review, общение в команде**
  - Владение английским языком необходимо для чтения технической документации, общения в международных командах, проведения code review, обсуждения архитектурных решений. Умение формулировать вопросы и отвечать на них на английском повышает эффективность работы и профессиональный рост.

---
 